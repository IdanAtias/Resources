ObjectTracer subclass: #ContractEnforcer	instanceVariableNames: 'obj'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ContractEnforcer methodsFor: 'very few messages' stamp: 'IA 5/8/2016 20:44'!on: o	obj:=o.	^ super on: o.! !!ContractEnforcer methodsFor: 'initialize-release' stamp: 'IA 5/8/2016 20:43'!initialize	obj:=nil.! !Object subclass: #ContractObject	instanceVariableNames: 'preCond postCond classInvar rescue'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ContractObject methodsFor: 'istance creation' stamp: 'LBA 5/8/2016 19:16'!new	^super new ContractEnforcer on: self.! !!ContractObject methodsFor: 'runtime-methods' stamp: 'LBA 5/8/2016 18:37'!classInvariant: code	(code isNil) ifTrue: [^nil].	^code copyReplaceTokens: '\"InavariantCheck\"' with: 'self InvariantCheck'.! !!ContractObject methodsFor: 'runtime-methods' stamp: 'LBA 5/8/2016 18:48'!compile: code notifying: requestor trailer: bytes ifFail: failBlock	self log: (self substring: code delimiter: '?').	preCond := super compile: (self preCondition: code) notifying: requestor trailer: bytes ifFail: failBlock.	postCond := super compile: (self postCondition: code) notifying: requestor trailer: bytes ifFail: failBlock.	classInvar := super compile: (self classInvariant: code) notifying: requestor trailer: bytes ifFail: failBlock.	rescue := super compile: (self rescue: code) notifying: requestor trailer: bytes ifFail: failBlock.	^super compile: code notifying: requestor trailer: bytes ifFail: failBlock.! !!ContractObject methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 16:44'!log: aMessage	Transcript show: aMessage;cr.! !!ContractObject methodsFor: 'runtime-methods' stamp: 'IA 5/8/2016 17:04'!postCondition: code	^ self xCondition: code delimiter: '@'! !!ContractObject methodsFor: 'runtime-methods' stamp: 'IA 5/8/2016 17:28'!preCondition: code	^ self xCondition: code delimiter: '%' ! !!ContractObject methodsFor: 'runtime-methods' stamp: 'IA 5/8/2016 17:04'!rescue: code	^ self xCondition: code delimiter: '!!'! !!ContractObject methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 17:21'!substring: aString delimiter: aDelimiter	|i first last|	i:=1.	first:=-1.	last:=-1.	aString do: [:ch|  ((ch asString) = aDelimiter ) ifTrue: [			(first = -1) ifTrue:				[first:=i] ifFalse: [last:=i] ].			i:=i+1].	(first = -1) ifTrue: [^nil] ifFalse: [^(aString copyFrom: (first+1) to: (last-1))].! !!ContractObject methodsFor: 'runtime-methods' stamp: 'IA 5/8/2016 17:30'!xCondition: code delimiter: d	| methodDec xCode prefix retval |	(code isEmpty) ifTrue: [^nil].	xCode := self substring: code delimiter: d.	(xCode isNil) ifTrue: [^nil].	methodDec := self getFirstLine: code.	retval := ''.	(d='%') ifTrue: [prefix:='PRE'].	(d='@') ifTrue: [prefix:='POST'. retval:=' retVal: return'].	(d='!!') ifTrue: [prefix:='RES'].	^ prefix, methodDec, retval, Character cr, xCode.		! !!ContractObject methodsFor: 'aux' stamp: 'IA 5/8/2016 16:45'!getEndIndexOfFirstLine: aString	| i | 	i:=0.	aString do: [ :ch | (ch = Character cr ) ifTrue: [ ^i ] ifFalse: [ i:= i+1 ] ].	! !!ContractObject methodsFor: 'aux' stamp: 'IA 5/8/2016 16:19'!getFirstLine: aString	^ aString copyFrom: 1 to: (self getEndIndexOfFirstLine: aString) ! !!ContractObject methodsFor: 'initialize-release' stamp: 'IA 5/8/2016 16:37'!initialize	preCond:= nil.	postCond:=nil.	classInvar:=nil.	rescue:=nil.! !