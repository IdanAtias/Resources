ObjectTracer subclass: #ContractEnforcer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ContractEnforcer methodsFor: 'error handling' stamp: 'LBA 5/20/2016 16:27'!doesNotUnderstand: aMsg	| tracedObj sel args preCond rescue isRescue isMsgFail postCond retVal postArgs|	tracedObj := self xxxViewedObject.	sel:= aMsg selector.	args:= aMsg arguments.	postArgs := args deepCopy. "	tracedObj perform: (s asSymbol) withArguments: aMsg arguments.""TODO: check here and the next raises if the fromMethod: argument shold be aMsg or preCond"	preCond := ('PRE',sel) asSymbol.	(tracedObj respondsTo: preCond) ifTrue:[		[ tracedObj perform: preCond withArguments: args] on: AssertionFailure do: 			 [AssertionFailure signal: (self xxxContractFailedAssertionText:  tracedObj className fromMethod: preCond)]	].	rescue :=  ('RES',sel) asSymbol.	isRescue := (tracedObj respondsTo: rescue).	isMsgFail :=true.	postCond := ('POST',sel,'retVal:') asSymbol.	[retVal := tracedObj perform: sel withArguments: args.	Transcript show: 'retVal is',retVal;cr.		Transcript show: 'postArgs class = ',(postArgs class );cr.	postArgs at: ((args size) +1) put: retVal.	Transcript show: 'postArgs at: ((args size) +1) = ',(postArgs at: ((args size) +1));cr.	isMsgFail:=false.	Transcript show: 'isMsgFail before is',isMsgFail;cr.	(tracedObj respondsTo: postCond) ifTrue:[ tracedObj perform: postCond withArguments: postArgs ].			] on: AssertionFailure, Error do: [ :msgE | (isRescue) ifFalse: [AssertionFailure signal: (self xxxContractFailedAssertionText:  tracedObj className fromMethod: ((isMsgFail) ifTrue:[Transcript show: isMsgFail;cr.sel] ifFalse: [postCond]) )] 															ifTrue: [ 																[tracedObj perform: rescue withArguments: args.																AssertionFailure signal: (self xxxRescueCodeAssertionText:  tracedObj className fromMethod: ((isMsgFail) ifTrue:[sel] ifFalse: [postCond]) withNote: msgE messageText)] 															on: AssertionFailure do: [ :resE | AssertionFailure signal: (self xxxRescueCodeAssertionText:  tracedObj className fromMethod: rescue withNote: resE messageText) ] 															]									] ! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:03'!xxxContractFailedAssertionText: className fromMethod: methodSelector"This function expects to receive the class name and the method selector of the class and method causing the assertion failure to be issued. It returns a string to be sent with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the method belongsmethodSelector - a String. Should hold the selector of the method which caused the AssertionFailure to be thrown (either the precondition or the postcondition)"	^('Contract failed at ', className, ' ', methodSelector asString)	! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:04'!xxxRescueCodeAssertionText: className fromMethod: methodSelector withNote: aNote"This function expects to receive the class name and the method selector of the class and method causing the rescue code to be called, along with a note as described below. It returns a string to be thrown with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the rescue code belongsmethodSelector - a String. Should hold the selector of the method which caused the rescue method to be called (either the postcondition or the original method itself).aNote - a String. If the rescue code threw an AssertionFailure this should be the AssertionFailure's text. If not, this 	should be an empty string ('') "	AssertionFailure signal: ('Rescue called at ', className, ' ', methodSelector, ' with note: ', aNote)! !Object subclass: #ContractObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ContractObject class	instanceVariableNames: ''!!ContractObject class methodsFor: 'instance creation' stamp: 'IA 5/20/2016 13:16'!new"	Transcript show: 'self: ', self; cr..	Transcript show: 'super: ',super;cr..	Transcript show: 'superclass:  ',superclass;cr."	^ContractEnforcer on: (super new)	! !!ContractObject class methodsFor: 'instance creation' stamp: 'LBA 5/19/2016 19:09'!newnew	^((ContractEnforcer new) on: self)! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:45'!classInvariant: code	((code isNil) or: (code='')) ifTrue: [^nil].	^(code copyReplaceTokens: '"InvariantCheck"' with: 'self InvariantCheck.').! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:51'!compile: code	^ super compile: (self classInvariant: code)! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:53'!compile: code notifying: requestor trailer: bytes ifFail: failBlock	"code here is after classInvariant"	| tmpCode|	tmpCode:=(self substring: code delimiter: '?'). 	(tmpCode isNil) ifFalse: [self log: tmpCode].	self preCondition: code.	self postCondition: code.	self rescue: code.	(code isNil) ifFalse: [^super compile: code notifying: requestor trailer: bytes ifFail: failBlock]	 	! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 16:44'!log: aMessage	Transcript show: aMessage;cr.! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!postCondition: code	| filtered |	filtered:=self xCondition: code delimiter: '@'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!preCondition: code	| filtered |	filtered:=self xCondition: code delimiter: '%'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!rescue: code	| filtered |	filtered:=self xCondition: code delimiter: '!!'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 17:21'!substring: aString delimiter: aDelimiter	|i first last|	i:=1.	first:=-1.	last:=-1.	aString do: [:ch|  ((ch asString) = aDelimiter ) ifTrue: [			(first = -1) ifTrue:				[first:=i] ifFalse: [last:=i] ].			i:=i+1].	(first = -1) ifTrue: [^nil] ifFalse: [^(aString copyFrom: (first+1) to: (last-1))].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 22:55'!xCondition: code delimiter: d	| methodDec xCode prefix retval |	(code='' or: code isNil "or: code isEmpty") ifTrue: [^nil].	xCode := self substring: code delimiter: d.	(xCode='' or: xCode isNil "or: xCode isEmpty") ifTrue: [^nil].	methodDec := self getFirstLine: code.	retval := ''.	(d='%') ifTrue: [prefix:='PRE'].	(d='@') ifTrue: [prefix:='POST'. retval:=' retVal: return'].	(d='!!') ifTrue: [prefix:='RES'].	^ prefix, methodDec, retval, Character cr, xCode.		! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:45'!getEndIndexOfFirstLine: aString	| i | 	i:=0.	aString do: [ :ch | (ch = Character cr ) ifTrue: [ ^i ] ifFalse: [ i:= i+1 ] ].	! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:19'!getFirstLine: aString	^ aString copyFrom: 1 to: (self getEndIndexOfFirstLine: aString) ! !ContractObject subclass: #Animal	instanceVariableNames: 'numOfLegs canMakeNoise'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/20/2016 11:23'!InvariantCheck	(numOfLegs = 0) ifTrue: [Transcript show: 'Inariant Check Worked';cr]	 ifFalse: [Transcript show: 'Inariant Check didnt Worked';cr].! !!Animal methodsFor: 'as yet unclassified' stamp: 'LBA 5/20/2016 16:27'!POSTmakeSound: aNoise retVal: returnself assert: [return]! !!Animal methodsFor: 'as yet unclassified' stamp: 'LBA 5/20/2016 16:27'!PREmakeSound: aNoiseself assert: [canMakeNoise = true]. Transcript show: 'in PRE...';cr.! !!Animal methodsFor: 'as yet unclassified' stamp: 'LBA 5/20/2016 14:55'!initialize	numOfLegs:=0.	canMakeNoise:=true.! !!Animal methodsFor: 'as yet unclassified' stamp: 'LBA 5/20/2016 16:27'!makeSound: aNoise"%self assert: [canMakeNoise = true]. Transcript show: 'in PRE...';cr.%""@self assert: [return]@"self InvariantCheck.Transcript show: 'code to make noise';cr. "This is the method code""this is just a comment"^false! !