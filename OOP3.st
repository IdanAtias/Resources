ObjectTracer subclass: #ContractEnforcer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/23/2016 20:06'!doesNotUnderstand: aMsg	| tracedObj sel args classHir preCond rescue isRescue methodRetVal postCond |	tracedObj := self xxxViewedObject.	args:= aMsg arguments.	((args isNil) or: (args size = 0)) ifTrue:[args:=#()].	classHir := self getHierarchy: (tracedObj class).	sel:= aMsg selector.	preCond := ('PRE',sel) asSymbol.	(self checkPreConditions: tracedObj selector: preCond args: args classHir: classHir) ifFalse: [ AssertionFailure signal: (self xxxContractFailedAssertionText:  (tracedObj className) fromMethod: preCond)].	rescue :=  ('RES',sel) asSymbol.	isRescue := ((tracedObj class) includesSelector: rescue).	rescue := (isRescue) ifTrue: [rescue] ifFalse: [nil].	methodRetVal := self execMethodAndRescue: tracedObj selector: sel args: args postArgs: nil rescue: rescue class: (tracedObj class) methodType: 'METH'.	"When reached here, methodRetVal has vaild value:"	(args=#()) ifTrue: [^methodRetVal]. 	postCond :=  ('POST',sel,'retVal:') asSymbol.	self checkPostConditionsAndHandleExcep: tracedObj classHir: classHir selector: postCond args: args retVal: methodRetVal rescue: rescue.	^methodRetVal! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:03'!xxxContractFailedAssertionText: className fromMethod: methodSelector"This function expects to receive the class name and the method selector of the class and method causing the assertion failure to be issued. It returns a string to be sent with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the method belongsmethodSelector - a String. Should hold the selector of the method which caused the AssertionFailure to be thrown (either the precondition or the postcondition)"	^('Contract failed at ', className, ' ', methodSelector asString)	! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:04'!xxxRescueCodeAssertionText: className fromMethod: methodSelector withNote: aNote"This function expects to receive the class name and the method selector of the class and method causing the rescue code to be called, along with a note as described below. It returns a string to be thrown with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the rescue code belongsmethodSelector - a String. Should hold the selector of the method which caused the rescue method to be called (either the postcondition or the original method itself).aNote - a String. If the rescue code threw an AssertionFailure this should be the AssertionFailure's text. If not, this 	should be an empty string ('') "	AssertionFailure signal: ('Rescue called at ', className, ' ', methodSelector, ' with note: ', aNote)! !!ContractEnforcer methodsFor: 'aux' stamp: 'IA 5/23/2016 20:05'!checkPostConditionsAndHandleExcep: tracedObj classHir: classHir selector: postCond args: args retVal: methodRetVal rescue: rescue	|postArgs|	postArgs:=args asOrderedCollection.	postArgs add: methodRetVal.	postArgs:= postArgs asArray.	classHir do: [:curr | (curr includesSelector: postCond) ifTrue: [			self execMethodAndRescue: tracedObj selector: postCond args: args postArgs: postArgs rescue: rescue class: curr methodType: 'POST'] ].	^true! !!ContractEnforcer methodsFor: 'aux' stamp: 'IA 5/23/2016 01:00'!checkPreConditions: tracedObj selector: preCond args: args classHir: classHir	(classHir) do: [ :curr | (curr includesSelector: preCond) ifTrue: [ [self evaluateCompMethod: tracedObj selector: preCond args: args class: curr. ^true ] on: AssertionFailure do: [] ] 		ifFalse:[^true] ].	^false! !!ContractEnforcer methodsFor: 'aux' stamp: 'IA 5/23/2016 00:11'!evaluateCompMethod: tracedObj selector: sel args:args class: curr		| compMethod |		compMethod:=((curr methodDict) at: sel).		^ (compMethod valueWithReceiver: tracedObj arguments: args)! !!ContractEnforcer methodsFor: 'aux' stamp: 'IA 5/23/2016 20:05'!execMethodAndRescue: tracedObj selector: sel args: args postArgs: postArgs rescue: rescue class: aClass methodType: type	|res|	 ((postArgs isNil) and: (((tracedObj class) includesSelector: sel)=false)) ifTrue: [ 		(tracedObj respondsTo: sel) ifTrue: [^tracedObj perform: sel withArguments: args].		((tracedObj class) respondsTo: sel) ifTrue: [^(tracedObj class) perform: sel withArguments: args].			].	[res:=self evaluateCompMethod: tracedObj selector: sel args: ((postArgs isNil) ifTrue:[args] ifFalse: [postArgs]) class: aClass] on: AssertionFailure, Error do: 		[:excM | (rescue isNil) ifTrue: [ ((type='POST') or: ((type='METH') and: (excM messageText = 'InvariantCheck') ) ) ifTrue: [					AssertionFailure signal: (self xxxContractFailedAssertionText: aClass fromMethod: sel)]				ifFalse:[excM signal] ]				 ifFalse: [				[ tracedObj perform: rescue withArguments: args]  on: AssertionFailure do: [					:excR | self xxxRescueCodeAssertionText: aClass  fromMethod: sel withNote: (excR messageText) ].					self xxxRescueCodeAssertionText: aClass  fromMethod: sel withNote: ''				]		].	^res! !!ContractEnforcer methodsFor: 'aux' stamp: 'IA 5/22/2016 21:26'!getHierarchy: aClass	|tmpClass collec|	tmpClass := aClass.	collec := OrderedCollection new.	[(tmpClass = ContractObject) or: (tmpClass isNil)] whileFalse: [		collec add: tmpClass. tmpClass:=(tmpClass superclass)].	(tmpClass isNil) ifTrue: [^nil] ifFalse:[^collec]	! !Object subclass: #ContractObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ContractObject class	instanceVariableNames: ''!!ContractObject class methodsFor: 'instance creation' stamp: 'IA 5/23/2016 20:06'!new	^ContractEnforcer on: (super new)	! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:45'!classInvariant: code	((code isNil) or: (code='')) ifTrue: [^nil].	^(code copyReplaceTokens: '"InvariantCheck"' with: 'self InvariantCheck.').! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:51'!compile: code	^ super compile: (self classInvariant: code)! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:53'!compile: code notifying: requestor trailer: bytes ifFail: failBlock	"code here is after classInvariant"	| tmpCode|	tmpCode:=(self substring: code delimiter: '?'). 	(tmpCode isNil) ifFalse: [self log: tmpCode].	self preCondition: code.	self postCondition: code.	self rescue: code.	(code isNil) ifFalse: [^super compile: code notifying: requestor trailer: bytes ifFail: failBlock]	 	! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 16:44'!log: aMessage	Transcript show: aMessage;cr.! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!postCondition: code	| filtered |	filtered:=self xCondition: code delimiter: '@'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!preCondition: code	| filtered |	filtered:=self xCondition: code delimiter: '%'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!rescue: code	| filtered |	filtered:=self xCondition: code delimiter: '!!'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 17:21'!substring: aString delimiter: aDelimiter	|i first last|	i:=1.	first:=-1.	last:=-1.	aString do: [:ch|  ((ch asString) = aDelimiter ) ifTrue: [			(first = -1) ifTrue:				[first:=i] ifFalse: [last:=i] ].			i:=i+1].	(first = -1) ifTrue: [^nil] ifFalse: [^(aString copyFrom: (first+1) to: (last-1))].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 22:55'!xCondition: code delimiter: d	| methodDec xCode prefix retval |	(code='' or: code isNil "or: code isEmpty") ifTrue: [^nil].	xCode := self substring: code delimiter: d.	(xCode='' or: xCode isNil "or: xCode isEmpty") ifTrue: [^nil].	methodDec := self getFirstLine: code.	retval := ''.	(d='%') ifTrue: [prefix:='PRE'].	(d='@') ifTrue: [prefix:='POST'. retval:=' retVal: return'].	(d='!!') ifTrue: [prefix:='RES'].	^ prefix, methodDec, retval, Character cr, xCode.		! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:45'!getEndIndexOfFirstLine: aString	| i | 	i:=0.	aString do: [ :ch | (ch = Character cr ) ifTrue: [ ^i ] ifFalse: [ i:= i+1 ] ].	! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:19'!getFirstLine: aString	^ aString copyFrom: 1 to: (self getEndIndexOfFirstLine: aString) ! !