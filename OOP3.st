ObjectTracer subclass: #ContractEnforcer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/22/2016 20:30'!doesNotUnderstand1: aMsg	| tracedObj preCond |"rescue isRescue isMsgFail postCond |"	tracedObj := self xxxViewedObject.	"TODO: check #"	preCond := #('PRE',aMsg).	Transcript show: 'This is aMsg: ',aMsg; cr.	"Transcript show: 'this is preCond: ',preCond."	tracedObj perform: aMsg." 'makeSound:' asSymbol with: 'blabla'."	"tracedObj makeSound: 'blalba'."	"TODO: check here and the next raises if the fromMethod: argument shold be aMsg or preCond"	"(tracedObj respondsTo: preCond) ifTrue:[ [ tracedObj preCond ] on: AssertionFailure do: [self xxxContractFailedAssertionText:  tracedObj className fromMethod: preCond]].	rescue :=  #('RES',aMsg).	isRescue := (tracedObj respondsTo: rescue).	isMsgFail :=true.	postCond := #('POST',aMsg).	[tracedObj aMsg.	isMsgFail:=false.	(tracedObj respondsTo: postCond) ifTrue:[ tracedObj postCond ].			] on: AssertionFailure, Error do: [ :msgE | (isRescue) ifFalse: [self xxxContractFailedAssertionText:  tracedObj className fromMethod: ((isMsgFail) ifTrue:[aMsg] ifFalse: [postCond]) ] 															ifTrue: [ 																[tracedObj rescue.																self xxxRescueCodeAssertionText:  tracedObj className fromMethod: ((isMsgFail) ifTrue:[aMsg] ifFalse: [postCond]) withNote: msgE 																messageText] 															on: AssertionFailure do: [ :resE | self xxxRescueCodeAssertionText:  tracedObj className fromMethod: rescue withNote: resE 																messageText ] 															]									] "! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/22/2016 21:53'!doesNotUnderstand: aMsg	| tracedObj sel args classHir preCond "rescue isRescue isMsgFail postCond retVal postArgs"|	tracedObj := self xxxViewedObject.	sel:= aMsg selector.	args:= aMsg arguments.	classHir := self getHierarchy: (tracedObj class).	(classHir isNil) ifTrue: [super doesNotUnderstand: aMsg].	preCond := ('PRE',sel) asSymbol.	(self checkPreConditions: tracedObj selector: preCond args: args classHir: classHir) ifFalse: [ AssertionFailure signal: (self xxxContractFailedAssertionText:  tracedObj className fromMethod: preCond)].	! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:03'!xxxContractFailedAssertionText: className fromMethod: methodSelector"This function expects to receive the class name and the method selector of the class and method causing the assertion failure to be issued. It returns a string to be sent with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the method belongsmethodSelector - a String. Should hold the selector of the method which caused the AssertionFailure to be thrown (either the precondition or the postcondition)"	^('Contract failed at ', className, ' ', methodSelector asString)	! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:04'!xxxRescueCodeAssertionText: className fromMethod: methodSelector withNote: aNote"This function expects to receive the class name and the method selector of the class and method causing the rescue code to be called, along with a note as described below. It returns a string to be thrown with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the rescue code belongsmethodSelector - a String. Should hold the selector of the method which caused the rescue method to be called (either the postcondition or the original method itself).aNote - a String. If the rescue code threw an AssertionFailure this should be the AssertionFailure's text. If not, this 	should be an empty string ('') "	AssertionFailure signal: ('Rescue called at ', className, ' ', methodSelector, ' with note: ', aNote)! !!ContractEnforcer methodsFor: 'aux' stamp: 'IA 5/22/2016 21:54'!checkPreConditions: tracedObj selector: preCond args: args classHir: classHir	|flag|	flag:=0. "if flag stays 0 then all preconds failed"	(classHir) do: [ :curr | [self evaluateCompMethod: tracedObj selector: preCond args: args class: curr. flag:=1] on: AssertionFailure do: [] ].	^(flag = 1) ! !!ContractEnforcer methodsFor: 'aux' stamp: 'IA 5/22/2016 21:54'!evaluateCompMethod: tracedObj selector: preCond args:args class: curr	(curr includesSelector: preCond) ifTrue: [		| compMethod |		compMethod:=((curr methodDict) at: preCond).		compMethod valueWithReceiver: tracedObj arguments: args]. ! !!ContractEnforcer methodsFor: 'aux' stamp: 'IA 5/22/2016 21:26'!getHierarchy: aClass	|tmpClass collec|	tmpClass := aClass.	collec := OrderedCollection new.	[(tmpClass = ContractObject) or: (tmpClass isNil)] whileFalse: [		collec add: tmpClass. tmpClass:=(tmpClass superclass)].	(tmpClass isNil) ifTrue: [^nil] ifFalse:[^collec]	! !Object subclass: #ContractObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ContractObject class	instanceVariableNames: ''!!ContractObject class methodsFor: 'instance creation' stamp: 'IA 5/20/2016 13:16'!new"	Transcript show: 'self: ', self; cr..	Transcript show: 'super: ',super;cr..	Transcript show: 'superclass:  ',superclass;cr."	^ContractEnforcer on: (super new)	! !!ContractObject class methodsFor: 'instance creation' stamp: 'LBA 5/19/2016 19:09'!newnew	^((ContractEnforcer new) on: self)! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:45'!classInvariant: code	((code isNil) or: (code='')) ifTrue: [^nil].	^(code copyReplaceTokens: '"InvariantCheck"' with: 'self InvariantCheck.').! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:51'!compile: code	^ super compile: (self classInvariant: code)! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:53'!compile: code notifying: requestor trailer: bytes ifFail: failBlock	"code here is after classInvariant"	| tmpCode|	tmpCode:=(self substring: code delimiter: '?'). 	(tmpCode isNil) ifFalse: [self log: tmpCode].	self preCondition: code.	self postCondition: code.	self rescue: code.	(code isNil) ifFalse: [^super compile: code notifying: requestor trailer: bytes ifFail: failBlock]	 	! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 16:44'!log: aMessage	Transcript show: aMessage;cr.! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!postCondition: code	| filtered |	filtered:=self xCondition: code delimiter: '@'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!preCondition: code	| filtered |	filtered:=self xCondition: code delimiter: '%'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!rescue: code	| filtered |	filtered:=self xCondition: code delimiter: '!!'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 17:21'!substring: aString delimiter: aDelimiter	|i first last|	i:=1.	first:=-1.	last:=-1.	aString do: [:ch|  ((ch asString) = aDelimiter ) ifTrue: [			(first = -1) ifTrue:				[first:=i] ifFalse: [last:=i] ].			i:=i+1].	(first = -1) ifTrue: [^nil] ifFalse: [^(aString copyFrom: (first+1) to: (last-1))].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 22:55'!xCondition: code delimiter: d	| methodDec xCode prefix retval |	(code='' or: code isNil "or: code isEmpty") ifTrue: [^nil].	xCode := self substring: code delimiter: d.	(xCode='' or: xCode isNil "or: xCode isEmpty") ifTrue: [^nil].	methodDec := self getFirstLine: code.	retval := ''.	(d='%') ifTrue: [prefix:='PRE'].	(d='@') ifTrue: [prefix:='POST'. retval:=' retVal: return'].	(d='!!') ifTrue: [prefix:='RES'].	^ prefix, methodDec, retval, Character cr, xCode.		! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:45'!getEndIndexOfFirstLine: aString	| i | 	i:=0.	aString do: [ :ch | (ch = Character cr ) ifTrue: [ ^i ] ifFalse: [ i:= i+1 ] ].	! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:19'!getFirstLine: aString	^ aString copyFrom: 1 to: (self getEndIndexOfFirstLine: aString) ! !ContractObject subclass: #Animal	instanceVariableNames: 'numOfLegs canMakeNoise'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/20/2016 11:23'!InvariantCheck	(numOfLegs = 0) ifTrue: [Transcript show: 'Inariant Check Worked';cr]	 ifFalse: [Transcript show: 'Inariant Check didnt Worked';cr].! !!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/22/2016 21:53'!POSTmakeSound: aNoise retVal: returnself assert: [return]! !!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/22/2016 21:53'!PREmakeSound: aNoiseself assert: [canMakeNoise = true]. Transcript show: 'in PRE...';cr.! !!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/22/2016 21:53'!RESmakeSound: aNoiseTranscript show: 'in RESCUE ' .! !!Animal methodsFor: 'as yet unclassified' stamp: 'LBA 5/20/2016 14:55'!initialize	numOfLegs:=0.	canMakeNoise:=true.! !!Animal methodsFor: 'as yet unclassified' stamp: 'LBA 5/22/2016 15:24'!makeSound: aNoise"%self assert: [canMakeNoise = true]. Transcript show: 'in PRE...';cr.%""@self assert: [return]@"self InvariantCheck.Transcript show: 'code to make noise';cr. "This is the method code"elf assert: [false]."this is just a comment""!!Transcript show: 'in RESCUE ' .!!"^true! !Animal subclass: #Bird	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!Bird subclass: #Heron	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!