ObjectTracer subclass: #ContractEnforcer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/20/2016 13:47'!doesNotUnderstand: aMsg	| tracedObj preCond |"rescue isRescue isMsgFail postCond |"	tracedObj := self xxxViewedObject.	"TODO: check #"	preCond := #('PRE',aMsg).	Transcript show: 'This is aMsg: ',aMsg; cr.	"Transcript show: 'this is preCond: ',preCond."	tracedObj perform: aMsg." 'makeSound:' asSymbol with: 'blabla'."	"tracedObj makeSound: 'blalba'."	"TODO: check here and the next raises if the fromMethod: argument shold be aMsg or preCond"	"(tracedObj respondsTo: preCond) ifTrue:[ [ tracedObj preCond ] on: AssertionFailure do: [self xxxContractFailedAssertionText:  tracedObj className fromMethod: preCond]].	rescue :=  #('RES',aMsg).	isRescue := (tracedObj respondsTo: rescue).	isMsgFail :=true.	postCond := #('POST',aMsg).	[tracedObj aMsg.	isMsgFail:=false.	(tracedObj respondsTo: postCond) ifTrue:[ tracedObj postCond ].			] on: AssertionFailure, Error do: [ :msgE | (isRescue) ifFalse: [self xxxContractFailedAssertionText:  tracedObj className fromMethod: ((isMsgFail) ifTrue:[aMsg] ifFalse: [postCond]) ] 															ifTrue: [ 																[tracedObj rescue.																self xxxRescueCodeAssertionText:  tracedObj className fromMethod: ((isMsgFail) ifTrue:[aMsg] ifFalse: [postCond]) withNote: msgE 																messageText] 															on: AssertionFailure do: [ :resE | self xxxRescueCodeAssertionText:  tracedObj className fromMethod: rescue withNote: resE 																messageText ] 															]									] "! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:03'!xxxContractFailedAssertionText: className fromMethod: methodSelector"This function expects to receive the class name and the method selector of the class and method causing the assertion failure to be issued. It returns a string to be sent with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the method belongsmethodSelector - a String. Should hold the selector of the method which caused the AssertionFailure to be thrown (either the precondition or the postcondition)"	^('Contract failed at ', className, ' ', methodSelector asString)	! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:04'!xxxRescueCodeAssertionText: className fromMethod: methodSelector withNote: aNote"This function expects to receive the class name and the method selector of the class and method causing the rescue code to be called, along with a note as described below. It returns a string to be thrown with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the rescue code belongsmethodSelector - a String. Should hold the selector of the method which caused the rescue method to be called (either the postcondition or the original method itself).aNote - a String. If the rescue code threw an AssertionFailure this should be the AssertionFailure's text. If not, this 	should be an empty string ('') "	AssertionFailure signal: ('Rescue called at ', className, ' ', methodSelector, ' with note: ', aNote)! !Object subclass: #ContractObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ContractObject class	instanceVariableNames: ''!!ContractObject class methodsFor: 'instance creation' stamp: 'IA 5/20/2016 13:16'!new"	Transcript show: 'self: ', self; cr..	Transcript show: 'super: ',super;cr..	Transcript show: 'superclass:  ',superclass;cr."	^ContractEnforcer on: (super new)	! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:45'!classInvariant: code	((code isNil) or: (code='')) ifTrue: [^nil].	^(code copyReplaceTokens: '"InvariantCheck"' with: 'self InvariantCheck.').! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:51'!compile: code	^ super compile: (self classInvariant: code)! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/20/2016 11:53'!compile: code notifying: requestor trailer: bytes ifFail: failBlock	"code here is after classInvariant"	| tmpCode|	tmpCode:=(self substring: code delimiter: '?'). 	(tmpCode isNil) ifFalse: [self log: tmpCode].	self preCondition: code.	self postCondition: code.	self rescue: code.	(code isNil) ifFalse: [^super compile: code notifying: requestor trailer: bytes ifFail: failBlock]	 	! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 16:44'!log: aMessage	Transcript show: aMessage;cr.! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!postCondition: code	| filtered |	filtered:=self xCondition: code delimiter: '@'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!preCondition: code	| filtered |	filtered:=self xCondition: code delimiter: '%'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 23:43'!rescue: code	| filtered |	filtered:=self xCondition: code delimiter: '!!'.	((filtered isNil) or: (filtered='')) ifFalse: [ self compile: filtered ].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 17:21'!substring: aString delimiter: aDelimiter	|i first last|	i:=1.	first:=-1.	last:=-1.	aString do: [:ch|  ((ch asString) = aDelimiter ) ifTrue: [			(first = -1) ifTrue:				[first:=i] ifFalse: [last:=i] ].			i:=i+1].	(first = -1) ifTrue: [^nil] ifFalse: [^(aString copyFrom: (first+1) to: (last-1))].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/18/2016 22:55'!xCondition: code delimiter: d	| methodDec xCode prefix retval |	(code='' or: code isNil "or: code isEmpty") ifTrue: [^nil].	xCode := self substring: code delimiter: d.	(xCode='' or: xCode isNil "or: xCode isEmpty") ifTrue: [^nil].	methodDec := self getFirstLine: code.	retval := ''.	(d='%') ifTrue: [prefix:='PRE'].	(d='@') ifTrue: [prefix:='POST'. retval:=' retVal: return'].	(d='!!') ifTrue: [prefix:='RES'].	^ prefix, methodDec, retval, Character cr, xCode.		! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:45'!getEndIndexOfFirstLine: aString	| i | 	i:=0.	aString do: [ :ch | (ch = Character cr ) ifTrue: [ ^i ] ifFalse: [ i:= i+1 ] ].	! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:19'!getFirstLine: aString	^ aString copyFrom: 1 to: (self getEndIndexOfFirstLine: aString) ! !ContractObject subclass: #Animal	instanceVariableNames: 'numOfLegs canMakeNoise'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/20/2016 11:23'!InvariantCheck	(numOfLegs = 0) ifTrue: [Transcript show: 'Inariant Check Worked';cr]	 ifFalse: [Transcript show: 'Inariant Check didnt Worked';cr].! !!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/20/2016 13:47'!POSTmakeSound: aNoise retVal: returnself assert: [numOfLegs >= 0]! !!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/20/2016 13:47'!PREmakeSound: aNoiseself assert: [canMakeNoise = true]! !!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/18/2016 23:22'!initialize	numOfLegs:=0.	canMakeNoise:=false.! !!Animal methodsFor: 'as yet unclassified' stamp: 'IA 5/20/2016 13:47'!makeSound: aNoise"%self assert: [canMakeNoise = true]%""@self assert: [numOfLegs >= 0]@"self InvariantCheck.Transcript show: aNoise;cr. "This is the method code""this is just a comment"! !