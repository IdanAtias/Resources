ObjectTracer subclass: #ContractEnforcer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 14:26'!doesNotUnderstand: aMsg	| tracedObj preCond rescue isRescue isMsgFail postCond |	tracedObj := self xxxViewedObject.	"TODO: check #"	preCond := #('PRE',aMsg).	"TODO: check here and the next raises if the fromMethod: argument shold be aMsg or preCond"	(tracedObj respondsTo: preCond) ifTrue:[ [ tracedObj preCond ] on: AssertionFailure do: [self xxxContractFailedAssertionText:  tracedObj className fromMethod: preCond]].	rescue :=  #('RES',aMsg).	isRescue := (tracedObj respondsTo: rescue).	isMsgFail :=true.	postCond := #('POST',aMsg).	[tracedObj aMsg.	isMsgFail:=false.	(tracedObj respondsTo: postCond) ifTrue:[ tracedObj postCond ].			] on: AssertionFailure, Error do: [ :msgE | (isRescue) ifFalse: [self xxxContractFailedAssertionText:  tracedObj className fromMethod: ((isMsgFail) ifTrue:[aMsg] ifFalse: [postCond]) ] 															ifTrue: [ 																[tracedObj rescue.																self xxxRescueCodeAssertionText:  tracedObj className fromMethod: ((isMsgFail) ifTrue:[aMsg] ifFalse: [postCond]) withNote: msgE messageText] 															on: AssertionFailure do: [ :resE | self xxxRescueCodeAssertionText:  tracedObj className fromMethod: rescue withNote: resE messageText ] 															]									] 			! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:03'!xxxContractFailedAssertionText: className fromMethod: methodSelector"This function expects to receive the class name and the method selector of the class and method causing the assertion failure to be issued. It returns a string to be sent with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the method belongsmethodSelector - a String. Should hold the selector of the method which caused the AssertionFailure to be thrown (either the precondition or the postcondition)"	^('Contract failed at ', className, ' ', methodSelector asString)	! !!ContractEnforcer methodsFor: 'error handling' stamp: 'IA 5/11/2016 13:04'!xxxRescueCodeAssertionText: className fromMethod: methodSelector withNote: aNote"This function expects to receive the class name and the method selector of the class and method causing the rescue code to be called, along with a note as described below. It returns a string to be thrown with an AssertionFailure. The parameters are:className - a String. Should hold the name of the class to which the rescue code belongsmethodSelector - a String. Should hold the selector of the method which caused the rescue method to be called (either the postcondition or the original method itself).aNote - a String. If the rescue code threw an AssertionFailure this should be the AssertionFailure's text. If not, this 	should be an empty string ('') "	AssertionFailure signal: ('Rescue called at ', className, ' ', methodSelector, ' with note: ', aNote)! !Object subclass: #ContractObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ContractObject class	instanceVariableNames: ''!!ContractObject class methodsFor: 'instance creation' stamp: 'IA 5/16/2016 15:08'!new	^(ContractEnforcer new) on: self.! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/8/2016 18:37'!classInvariant: code	(code isNil) ifTrue: [^nil].	^code copyReplaceTokens: '\"InavariantCheck\"' with: 'self InvariantCheck'.! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/16/2016 19:06'!compile: code notifying: requestor trailer: bytes ifFail: failBlock	| methods|	""	methods := Set new.	self log: (self substring: code delimiter: '?').	((self preCondition: code) isNil ) ifFalse: [methods add: (super compile: (self preCondition: code) notifying: requestor trailer: bytes ifFail: failBlock)].	((self postCondition: code) isNil ) ifFalse: [methods add: (super compile: (self postCondition: code) notifying: requestor trailer: bytes ifFail: failBlock)].	((self rescue: code) isNil ) ifFalse: [methods add: (super compile: (self rescue: code) notifying: requestor trailer: bytes ifFail: failBlock)].	((self classInvariant: code) isNil ) ifFalse: [methods add: (super compile: (self classInvariant: code) notifying: requestor trailer: bytes ifFail: failBlock)].	^methods! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 16:44'!log: aMessage	Transcript show: aMessage;cr.! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/8/2016 17:04'!postCondition: code	^ self xCondition: code delimiter: '@'! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/8/2016 17:28'!preCondition: code	^ self xCondition: code delimiter: '%' ! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/8/2016 17:04'!rescue: code	^ self xCondition: code delimiter: '!!'! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'LBA 5/6/2016 17:21'!substring: aString delimiter: aDelimiter	|i first last|	i:=1.	first:=-1.	last:=-1.	aString do: [:ch|  ((ch asString) = aDelimiter ) ifTrue: [			(first = -1) ifTrue:				[first:=i] ifFalse: [last:=i] ].			i:=i+1].	(first = -1) ifTrue: [^nil] ifFalse: [^(aString copyFrom: (first+1) to: (last-1))].! !!ContractObject class methodsFor: 'runtime-methods' stamp: 'IA 5/8/2016 17:30'!xCondition: code delimiter: d	| methodDec xCode prefix retval |	(code isEmpty) ifTrue: [^nil].	xCode := self substring: code delimiter: d.	(xCode isNil) ifTrue: [^nil].	methodDec := self getFirstLine: code.	retval := ''.	(d='%') ifTrue: [prefix:='PRE'].	(d='@') ifTrue: [prefix:='POST'. retval:=' retVal: return'].	(d='!!') ifTrue: [prefix:='RES'].	^ prefix, methodDec, retval, Character cr, xCode.		! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:45'!getEndIndexOfFirstLine: aString	| i | 	i:=0.	aString do: [ :ch | (ch = Character cr ) ifTrue: [ ^i ] ifFalse: [ i:= i+1 ] ].	! !!ContractObject class methodsFor: 'aux' stamp: 'IA 5/8/2016 16:19'!getFirstLine: aString	^ aString copyFrom: 1 to: (self getEndIndexOfFirstLine: aString) ! !!ContractObject class methodsFor: 'as yet unclassified' stamp: 'IA 5/16/2016 17:42'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource 	| methods selector |	methods := self		compile: text asString		notifying: requestor		trailer: (self defaultMethodTrailerIfLogSource: logSource)		ifFail: [ ^ nil ].	methods do: [ :methodAndNode | 	|s1|	s1 := methodAndNode selector.	logSource ifTrue:		[ self			logMethodSource: text			forMethodWithNode: methodAndNode			inCategory: category			withStamp: changeStamp			notifying: requestor.		RecentMessages default			recordSelector: s1			forClass: methodAndNode method methodClass			inEnvironment: CurrentEnvironment signal ].	self		addAndClassifySelector: s1		withMethod: methodAndNode method		inProtocol: category		notifying: requestor.	self instanceSide		noteCompilationOf: s1		meta: self isClassSide.		selector := s1 		].	^ selector! !